import java.util.*;

public class ProfessorTree<T> implements Iterable<T> {
  private T[] tree; 
  private int count; 
  private final int NOT_FOUND=-1;
  
  public GenealogyTree (T root) { 
    tree = (T[])new Object[]{root}; 
    count=1; 
  }
  
  //  Expands T[] tree when it's too small to accomodate new family
  private void expand() { 
    //decided to expand by 2 times + 1 whenever necessary (this  
    //works well b/c each new generation has as many members as 
    //the previous generation multiplied by 2, adding 1
    T[] temp = (T[])new Object[tree.length*2+1];
    for (int i=0; i<tree.length; i++) { 
      temp[i]=tree[i]; 
    }
    tree=temp; 
  }
  
  //  Returns the element stored in the root (aka CoTU) of the tree.
  public T getCoTU() { 
    return tree[0]; 
  }
  
  //  indexOf() finds the index of the T target in the T[] tree
  //  it returns NOT_FOUND if the target does not exist in T[] tree
  private int indexOf (T target) { 
    for (int i=0; i<tree.length; i++) { 
      if (tree[i]!=null && tree[i].equals(target)) { 
        return i; 
      }
    }
    return NOT_FOUND; 
  }
  
  //  Returns the member that is the offspring of target.
  //  Returns null as the offspring of the root.
  public T getOffspring(T target) { 
    try { 
      //returns the T object stored in the ((index+1)/2)-1 slot 
      //no need to check for nulls b/c the offspring is the 
      //parent (in Tree terms) of the target
      //decided to use this formula instead of (index-1)/2 b/c 
      //this formula works for every case, while the other formula 
      //doesn't work for index 0
      return tree[((indexOf(target)+1)/2)-1];
    } catch (ArrayIndexOutOfBoundsException aioobe) { 
      /*if (getCoTU().equals(target)) { 
        System.out.println("The target " + target + " does not have offspring."); 
      } else { 
        //if the target isn't the CoTU, and the program is running into aioobe, 
        //then that means the target does not exist
        System.out.println("The target " + target + " does not exist."); 
      }*/
      return null; 
    }
  }
  
  //  Returns the member that is the left child of target.
  //  Returns null if the left child does not exist.
  public T getPater(T target) { 
    //(indexOf(target)*2)+1 is the left-side child (Tree term)
    //if the index of the left-side child (Tree term is empty, 
    //it should still return null
    try { 
      return tree[(indexOf(target)*2)+1]; 
    } catch (ArrayIndexOutOfBoundsException aioobe) { 
      return null; 
    }
  }
  
  //  Sets the left child of the tree target to lchild.
  //  It throws an exception if target is not already in the tree
  public void setPater(T target, T lchild) { 
    try { 
      //checks to see if target exists
      if (indexOf(target)==NOT_FOUND) { 
        //System.out.println("The target " + target + " does not exist.");       
      } else { 
        int cIndex = (indexOf(target)*2)+1;
        //if T[] tree isn't big enough (ie: the length of the tree is 
        //less than or equal to the index necessary to house the lchild), 
        //then expand
        if (cIndex>=tree.length) {
          expand(); 
        }
        //if the target doesn't have a pater, then this is the first pater, so we
        //increment count; however, if the target does have a pater, then we still 
        //want to set tree[cIndex] to lchild, but we don't want to increment
        if (getPater(target)==null) {
          count++; 
        }
        tree[cIndex]=lchild; 
      }
    } catch (ArrayIndexOutOfBoundsException aioobe) { 
      //System.out.println("The target " + target + " does not exist.");
    }
    
  }
  
  //  Returns the element that is the right child of target.
  //  Returns null if the right child does not exist
  public T getMater(T target) { 
    //(indexOf(target)*2)+2 is the right-side child (Tree term)
    //if the index of the right-side child (Tree term is empty, 
    //it should still return null
    try {
      return tree[(indexOf(target)*2)+2]; 
    } catch (ArrayIndexOutOfBoundsException aioobe) {
      return null;
    }
  }
  
  //  Sets the right child of target to rchild.
  //  It throws an exception if target is not already in the tree
  public void setMater(T target, T rchild) {
    try { 
      //checks to see if target exists
      if (indexOf(target)==NOT_FOUND) { 
        //System.out.println("The target " + target + " does not exist."); 
      } else {
        int cIndex = (indexOf(target)*2)+2;
        //if T[] tree isn't big enough (ie: the length of the tree is 
        //less than or equal to the index necessary to house the rchild), 
        //then expand
        if (cIndex>=tree.length) {
          expand(); 
        }
        //if the target doesn't have a mater, then this is the first mater, so we
        //increment count; however, if the target does have a mater, then we still 
        //want to set tree[cIndex] to rchild, but we don't want to increment count
        if (getMater(target)==null) {
          count++; 
        }
        tree[cIndex]=rchild; 
      }
    } catch (ArrayIndexOutOfBoundsException aioobe) { 
      //System.out.println("The target " + target + " does not exist.");
    }
  }
  
  //  Returns true if the tree contains an element that
  //  matches the specified target element and false otherwise.
  public boolean appears (T target) {
    //if the target exists in the array, then it must have an index 
    //so, as long as indexOf() produces something other than -1, 
    //target exists
    return (indexOf(target)>=0); 
  }
  
  // Returns true if the two members share a grandchild,
  // and false if they are not or if a shared grandchild does not exist
  // Two grandparents that share a grandchild are "inLaws"
  public boolean inLaws(T gp1, T gp2) { 
    try { 
      return (getOffspring(getOffspring(gp1)).equals(getOffspring(getOffspring(gp2)))); 
      //if we try to access an offspring that doesn't exist 
      //(ie: go beyond the root), then return false
    } catch (NullPointerException npe) { 
      return false; 
    }
  }
  
  //  Returns the number of members in this ancestral tree.
  public int size() { 
    return count; 
  }
  
  //  Returns the string representation of the binary tree,
  //  one line per level.
  public String toString() { 
    String s = "My genealogy contains " + count + " members:\n"; 
    Iterator<T> iter = iterator();
    int index=0; 
    int num=1; 
    while (iter.hasNext()) { 
      s+=iter.next(); 
      //this adds either a space or a line break in the String output
      //the program adds the line break in b/w generations
      //to determine where a generation stops/begins, the program takes
      //int n-1 (must subtract 1 b/c index refers to the index of the array 
      //that the object is in, whereas num refers to its count)
      if (index==num-1) { 
        s+="\n";
        //updates n so that it is now equal to the count at which the 
        //next generation begins
        num = (num*2)+1; 
      } else { 
        s+=" "; 
      }
      index++;
    }
    return s;   
  }
  
  //  Set to return a level-order traversal of the tree (byGenerations())
  public Iterator<T> iterator() { 
    return byGenerations();
  }
  
  //  Returns an iterator that contains a level-order traversal
  //  on the ancestral tree.
  public Iterator<T> byGenerations() {
    LinkedQueue<BTNode<T>> queue = new LinkedQueue<BTNode<T>>();
    ArrayIterator<T> iter = new ArrayIterator<T>();
    for (int i=0; i<tree.length; i++) {
      queue.enqueue(new BTNode(tree[i]));
      while (!queue.isEmpty()) {
        BTNode<T> current = queue.dequeue();
        //middle
        iter.add (current.getElement());
        //left
        if (current.getLeft() != null)
          queue.enqueue(current.getLeft());
        //right
        if (current.getRight() != null)
          queue.enqueue(current.getRight());
      }
    }
    return iter;
  }
  
  public static void main (String[] args) { 
    //testing normal tree
    GenealogyTree<String> fam = new GenealogyTree<String>("L"); 
    System.out.println("getCoTU() - Should print L: " + fam.getCoTU()); 
    System.out.println("getOffspring - Should print null: " + fam.getOffspring("L")); 
    fam.setPater("L","A"); 
    fam.setMater("L","B"); 
    System.out.println("getOffspring - Should print L: " + fam.getOffspring("A")); 
    System.out.println("getOffspring - Should print L: " + fam.getOffspring("B")); 
    System.out.println("getOffspring - Should print null: " + fam.getOffspring("C")); 
    System.out.println("getPater - Should print A: " + fam.getPater("L")); 
    System.out.println("getPater - Should print null: " + fam.getPater("A")); 
    System.out.println("getPater - Should print null: " + fam.getPater("C")); 
    System.out.println("getMater - Should print B: " + fam.getMater("L")); 
    System.out.println("getMater - Should print null: " + fam.getMater("A")); 
    System.out.println("getMater - Should print null: " + fam.getMater("C")); 
    fam.setPater("C","D"); 
    fam.setMater("C","D"); 
    System.out.println(fam); 
    System.out.println("Reseting L's Pater to D and L's Mater to E"); 
    fam.setPater("L","D"); 
    fam.setMater("L","E"); 
    System.out.println(fam); 
    System.out.println("size - Should print 3: " + fam.size()); 
    System.out.println("appears - Should print true: " + fam.appears("D")); 
    System.out.println("appears - Should print false: " + fam.appears("B")); 
    fam.setPater("D","F"); 
    fam.setMater("E","G"); 
    System.out.println(fam); 
    System.out.println("size - Should print 5: " + fam.size()); 
    System.out.println("inLaws - Should print true: " + fam.inLaws("F","G")); 
    System.out.println("inLaws - Should print false: " + fam.inLaws("D","E")); 
    System.out.println("inLaws - Should print false: " + fam.inLaws("L","A")); 
    System.out.println("inLaws - Should print false: " + fam.inLaws("L","Z")); 
    fam.setPater("F","H"); 
    fam.setMater("F","I"); 
    fam.setPater("G","J"); 
    fam.setMater("G","K"); 
    System.out.println(fam); 
    System.out.println("size - Should print 9: " + fam.size()); 
    //empty strings also work
    //GenealogyTree<String> empty = new GenealogyTree<String>(""); 
    //empty.setPater(""," "); 
    //System.out.println(empty); 
    

  }
}